<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html xmlns:background-color="http://www.w3.org/1999/xhtml" xmlns:max-width="http://www.w3.org/1999/xhtml">
<head>
    <title>VT AR Tour Documentation</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <!--[if lte IE 8]>
    <script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" href="../../assets/css/main.css"/>
    <link rel="stylesheet" href="../../assets/css/custom.css"/>
    <link rel="stylesheet" href="documentation.css"/>

    <!--Code Syntax Highlighting JS library-->
    <link rel="stylesheet" href="../../assets/css/xcode.css"/>
    <script src="../../assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>

<!-- Wrapper -->
<div id="wrapper">

    <!-- Main -->
    <div id="main">
        <div class="inner">

            <!-- Header -->
            <header id="header">
                <a href="" class="logo">Documentation</a>
            </header>

            <!-- Content -->
            <section>
                <h2>Overview</h2>
                <p>The hierarchical documentation documents how to build many of the functionalities found in the AR
                    Tour.</p>
            </section>

            <section>
                <h2>Getting Started - Project Creation and Environment Configuration</h2>
                <h3>Creating the project</h3>
                <p>ARKit projects requires Xcode 9.0 and above.</p>
                <ol>
                    <li>Launch Xcode and select <b>Create a new Xcode project</b> from the Xcode welcome screen, or
                        select
                        <b>File
                            → New → Project...</b></li>
                    <li>Choose <b> iOS → Application → Augmented Reality App</b> and click next.<br><img
                            src="../common-images/application-type-selection.png" width="70%"/></li>
                    <li>In the <i>Choose options for your new project</i> dialog, choose <b>SceneKit</b> as the <i>Content
                        Technology</i><img
                            src="../common-images/scenekit.png" width="70%"/></li>
                </ol>

                <h3>Configuring Your Environment</h3>
                <p>Creating a new ARKit project generates a sample application, so some cleanup is required.</p>
                <ol>
                    <li>In ViewController.swift, delete the sample code from <code>viewDidLoad()</code>.<br><img
                            src="../common-images/viewDidLoad.png" width="70%"/></li>
                    <li>Delete everything inside the art.scnassets folder. <br><img src="../common-images/art.png"
                                                                                    width="70%"/></li>
                </ol>

                <h3>Creating an AR Session</h3>
                <p><a href="https://developer.apple.com/documentation/arkit/arsession" target="_blank">ARSession</a> is
                    an
                    object shared by views that require motion tracking and image processing. Your application will use
                    an <a
                            href="https://developer.apple.com/documentation/arkit/arscnview">ARSCNView</a> to display 3D
                    SceneKit objects in the camera view.</p>
                <p>ARSession must be configured before it can be run by ARSCNView. To do this, create an instance of <a
                        href="https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration"
                        target="_blank">ARWorldTrackingConfiguration</a>
                    and configure it to detect horizontal planes. Then the SceneView can run the ARSession.</p>
                <p>This configuration can be achieved by adding the following code to the <code>viewWillAppear()</code>
                    method of your ViewController class.</p>

                <pre><code>
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)

    // Create a session configuration
    let configuration = ARWorldTrackingConfiguration()

    // Detect horizontal planes in the scene
    configuration.planeDetection = .horizontal

    // Run the view's session
    sceneView.session.run(configuration)
}
            </code></pre>


            </section>

            <section>
                <h2>Contextual Hints</h2>
                <div class="row">
                    <div class="column">
                        <p>Displaying help messages and hints in AR/VR is difficult to do without disrupting the user's
                            experience. One approach is to show context-sensitive hints in an overlay. This approach has
                            two advantages: the user is unlikely to miss these hints, and they don't disrupt the current
                            application flow. One disadvantage to this approach is that is can be difficult to determine
                            when to display these types of hints.</p>
                    </div>
                    <div class="column" align="center">
                        <img src="images/hint.gif" width="50%"/>
                    </div>
                </div>

                <h3>Creating an Overlay Hint</h3>
                <p>Recall that an ARSCNView contains a SceneKit scene. All SceneKit scenes contain a <code>overlaySKScene</code>,
                    perfect for overlaying 2D SpriteKit content. It's commonly used in game development to implement
                    heads-up displays, but can just as easily be used to create overlay labels.</p>
                <p>Create your <code>overlaySKScene</code> in your <code>viewDidLoad()</code> method. You'll want to
                    fade this overlay in and out. Creation and animation are discussed below.</p>
                <pre><code>
    override func viewDidLoad() {
        ...
        sceneView.overlaySKScene = createOverlayHintLabel(withText: "Your hint text here")
        fadeNodeInAndOut(node: sceneView.overlaySKScene!, initialDelay: 2.0, fadeInDuration: 1.0, displayDuration: 6.0, fadeOutDuration: 1.0)
        ...
    }
                </code></pre>

                <h3>Creating the Overlay</h3>
                <p>This function returns an SKScene which contains a SKLabelNode that wraps the string
                    <code>withText</code>, similar to the one shown above.</p>
                <pre><code>

    // Creates an overlay containing a label with hint text and a translucent background
    func createOverlayHintLabel(withText: String) -> SKScene {
        // Create an overlay banner to be positioned in the middle of the SceneView.
        let overlayScene = SKScene(size: sceneView.bounds.size)
        overlayScene.scaleMode = .resizeFill

        // Configure the hint label
        let hintLabel = SKLabelNode(text: withText)
        hintLabel.fontSize = 40
        hintLabel.verticalAlignmentMode = .center
        hintLabel.preferredMaxLayoutWidth = overlayScene.size.width
        hintLabel.numberOfLines = 2
        hintLabel.lineBreakMode = .byWordWrapping

        // Configure the label background
        let labelBackground = SKShapeNode()

        // Give the background a slightly larger bounding rectangle in order to give the text a margin.
        let labelBackgroundSizeRect = hintLabel.frame.insetBy(dx: -10, dy: -10)
        labelBackground.path = CGPath(roundedRect: labelBackgroundSizeRect, cornerWidth: 5, cornerHeight: 5, transform: nil)
        labelBackground.position = CGPoint(x: sceneView.frame.midX, y: sceneView.frame.midY)
        labelBackground.strokeColor = UIColor.clear
        labelBackground.fillColor = UIColor.init(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.96)
        labelBackground.addChild(hintLabel)

        // Add the overlay and its contents to the scene.
        overlayScene.addChild(labelBackground)
        overlayScene.alpha = 0

        return overlayScene
    }
                </code></pre>

                <h3>Displaying the Overlay</h3>
                <p>Animating hints makes your app look more polished, and it makes displaying hints less jarring to the
                    user. This function fades in a SKNode, displays it for <code>displayDuration</code> seconds. This
                    function can be reused with any SKNode, not just an overlay.</p>

                <pre><code>
   func fadeNodeInAndOut(node: SKNode, initialDelay: Double, fadeInDuration: Double, displayDuration: Double, fadeOutDuration: Double) {
        // Fade in the label
        node.run(SKAction.sequence([
            .wait(forDuration: initialDelay),
            .fadeIn(withDuration: fadeInDuration)]))

        // Wait and fade out the label
        node.run(SKAction.sequence([
            .wait(forDuration: displayDuration),
            .fadeOut(withDuration: fadeOutDuration),
            .removeFromParent()]))
    }
                </code></pre>

            </section>

            <section>
                <h2>Location-Based AR</h2>
                <div class="row">
                    <div class="column">
                        <p>VT AR Tour pulls lat/long coordinates from an API and translates them into a local coordinate
                            system in order to render objects at their "real" positions in the virtual coordinate
                            system. This processing is very tricky, but if done correctly, objects can be rendered in
                            their real-world locations with a surprising level of accuracy!</p>
                    </div>
                    <div class="column" align="center">
                        <div>
                            <img src="../../images/ar-map.jpeg" width="45%"/>
                            <img src="../../images/vt-ar-tour.gif" width="45%"/>
                        </div>
                    </div>
                </div>

                <h3>Getting the User's Location</h3>
                <p>A location-based AR App needs the highest degree of accuracy in order to correctly map real-world
                    coordinates to virtual ones. First get permission from the user, then configure the
                    CoreLocationManager to use the best accuracy possible.</p>
                <p>Make sure you have a strong reference to CLLocationManager, then get permission and configure the
                    location manger after the view has loaded.</p>
                <pre><code>
// A strong reference to CLLocationManager is required by the CoreLocation API
var locationManager = CLLocationManager()

override func viewDidLoad() {
    ...
    // User must enable location services to use this app
    if !CLLocationManager.locationServicesEnabled() {
        showAlertMessage(title: "Location Services Disabled", message: "You must enable location services to use this app")
        return
    }

    // Get the user's location
    locationManager.requestWhenInUseAuthorization()
    getLocation()
    ...
}

// Gets the user's location and reports all device movement
func getLocation() {
    // The user has not authorized location monitoring
    if (CLLocationManager.authorizationStatus() == .denied) {
        showAlertMessage(title: "App Not Authorized", message: "Unable to determine your location: please allow VT AR Tour to use your location.")

        // Try to get location authorization again
        locationManager.requestWhenInUseAuthorization()
    }

    locationManager.delegate = self

    // Report ALL device movement
    locationManager.distanceFilter = kCLDistanceFilterNone

    // Get the highest possible degree of accuracy
    locationManager.desiredAccuracy = kCLLocationAccuracyBest

    locationManager.startUpdatingLocation()
    locationManager.startUpdatingHeading()
}
                </code></pre>

                <h3>Setting up Your Coordinate System</h3>
                <p>When an ARSession is launched, the AR coordinate system is based on the angle of the camera upon
                    launch by default. Luckily, ARKit can base the coordinate system on gravity and the compass heading
                    for a more real-world-like coordinate system.</p>
                <p>When you create your <code>ARWorldTrackingConfiguration</code>, be sure to correctly set the world
                    alignment.</p>
                <pre><code>
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    let configuration = ARWorldTrackingConfiguration()

    // Defines the ARSession's coordinate system based on gravity and the compass heading in the device. Note: THIS IS CRITICALLY IMPORTANT for location-based AR applications
    configuration.worldAlignment = .gravityAndHeading
    ...
    // Run the view's session
    sceneView.session.run(configuration)
}
                </code></pre>

                <h3>Handling Location Updates</h3>
                <p>As the user moves around, the LocationManager will notify your application with location updates. You
                    should update the location of each object in the scene every time this method is called. Here, those
                    updates are handled in <code>processBuilding()</code>.</p>
                <pre><code>
// New location data is available
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    //  Must wait until at least one heading update comes through. If we proceed before this, our coordinate system won't be set up correctly
    guard (manager.heading?.magneticHeading) != nil else { return }

    // Don't process any further without the user's current location
    guard let currentLocation: CLLocation = locations.last else { return }

    // Fetch the VT Buildings JSON if necessary
    if jsonInDocumentDirectory == nil {
        jsonInDocumentDirectory = getVTBuildingsJSON()
    }

    if let jsonDataFromApi = jsonInDocumentDirectory {
        // Getting the JSON was successful
        do {
            let jsonArray = try JSONSerialization.jsonObject(with: jsonDataFromApi, options: .mutableContainers) as! NSArray

            for building in jsonArray {
                // Update the location and appearance of each buildingNode as necessary
                processBuilding(building, currentLocation)
            }
        } catch let error as NSError {
            showAlertMessage(title: "Error in JSON serialization", message: error.localizedDescription)
        }
    }
}
                </code></pre>

                <hr/>
                <h2>Processing Buildings</h2>
                <p>We create and render building nodes the first time we receive a location update. Afterwards, we
                    update the position and appearance of the building nodes with each location update.</p>
                <p>The rest of this section will focus on each step of processing, updating, and rendering
                    buildings.</p>
                <br/>
                <h3>Processing Buildings - Computing the Distance Between Coordinates</h3>
                <p>First, we determine if the building is close enough to the user to bother processing. If the building
                    is more than a quarter mile from the user, we don't waste CPU cycles updating nodes that are too far
                    for the user to see.</p>
                <img src="images/compute-distance.png" width="800"/>
                <p>The <code>distanceBetweenPointsInMiles()</code> function uses the <a
                        href="https://en.wikipedia.org/wiki/Haversine_formula" target="_blank">Haversine Formula</a> to
                    calculate the distance between two latitude/longitude points. Here, the points are the user's
                    location and each building's location.</p>
                <pre><code>
// MARK: - Degrees <--> Radians conversion functions

func degreesToRadians(_ degrees: Double) -> Double { return degrees * .pi / 180.0 }
func radiansToDegrees(_ radians: Double) -> Double { return radians * 180.0 / .pi }

// ----------------------------------------------
// MARK: - Position math (lat/long; matrix, etc)
// ----------------------------------------------

// MARK: Haversine formula
// Calculates the distance between two lat/long coordinates in miles.
// Modified from https://gist.github.com/Jamonek/16ecda78cebcd0da5862
func distanceBetweenPointsInMiles(lat1: Double, long1: Double, lat2: Double, long2: Double) -> Double {
    let radius: Double = 3959.0 // Average radius of the Earth in miles
    let deltaP = degreesToRadians(lat2) - degreesToRadians(lat1)
    let deltaL = degreesToRadians(long2) - degreesToRadians(long1)
    let a = sin(deltaP/2) * sin(deltaP/2) + cos(degreesToRadians(lat1)) * cos(degreesToRadians(lat2)) * sin(deltaL/2) * sin(deltaL/2)
    let c = 2 * atan2(sqrt(a), sqrt(1-a))
    let d = radius * c
    return d
}
                </code></pre>

                <h3>Processing Buildings - Creating Building Label Nodes</h3>
                <p>Once we've computed a building's distance from the user, we create a SCNNode containing the
                    building's name. Later, we will add this node to the scene.</p>
                <img src="images/create-building-label-node-highlight.png" width="800"/>
                <p><code>createBuildingLabelNode()</code> creates a SCNNode that displays the building's name. This takes a few steps:</p>
                <ol>
                    <li style="color: rgb(238, 64, 38)">Call <code>getARCoordinateOfBuilding()</code>, which translates the building's
                    real-world coordinates to its corresponding AR coordinates. </li>
                    <li style="color:rgb(0, 63, 245)">Get the (x, y, z) coordinates from the matrix's 3rd column (column 3 represents the node's position in 3D space) and wrap the coordinates into a SCNVector3. SCNNode expects a SCNVector3 type in order to set its position.</li>
                    <li style="color: rgb(111, 243, 74)">Set the node's properties.</li>
                </ol>
                <p>These tasks are nontrivial, so each will be discussed in detail below. The numerical labels that follow correspond the the numbers above.  </p>
                <img src="images/create-building-label-node.png" width="800"/>

            </section>

            <section>
                <h2>Leaving an AR View</h2>
                <div class="row">
                    <div class="column">
                        <p>If your application is more than just one ARSCNView, it may make sense to allow your user to
                            escape the ARSCNView and go back to the previous view. There are <b>two</b> easy ways to do
                            this: a back button and a UINavigationController.</p>
                    </div>
                    <div class="column" align="center">
                        <img src="images/exit-ar.jpeg" width="50%"/>
                    </div>
                </div>

                <h3>Option 1: Back Button&nbsp;&nbsp;<i class="fa fa-mail-reply fa-2x"></i></h3>
                <p>A back button is familiar to all users. In order to prevent disrupting your user's experience, you'll
                    only want to show it for a few seconds.</p>
                <h4>Button Setup</h4>
                <p>Call <code>setupBackButton()</code> in <code>viewWillAppear()</code> to create a back button and
                    display it for a few seconds.</p>
                <pre><code>
    // Global reference to backButton
    var backButton: UIImageView = UIImageView(image: UIImage(named: "back-icon"))

    // Creates a back button and adds it to the scene
    func setupBackButton() {
        // Position the button right under the status bar
        backButton.frame = CGRect(x: 25, y: 40, width: 35, height: 35)
        view.addSubview(backButton)

        // Fade out the back button after a few seconds.
        UIView.animateKeyframes(withDuration: 1.0, delay: 6.0, options: .allowUserInteraction, animations: {
            self.backButton.alpha = 0
        }, completion: { (finished: Bool) in
            self.backButton.isHidden = true
        })
    }
                </code></pre>

                <h4>Detecting a Back Button Press</h4>
                <p>You will likely be using hit tests (as learned in the <a href="../models-and-physics/tutorial.html">models
                    and physics</a> tutorial to determine if the user tapped an object in the scene. Rather than adding
                    a TapGestureRecognizer to our back button and overcomplicating the way our application handles tap
                    gestures, we can add our back button logic to our ARSCNView's tap gesture handling method. </p>
                <p>Add this code to your tap handling method to return to the previous ViewController when the user taps
                    the back button.</p>
                <pre><code>
    @IBAction func userTappedScreen(_ sender: UITapGestureRecognizer) {
        let screenTapPoint: CGPoint = sender.location(in: self.view)

        // User tapped the back button
        if backButton.frame.contains(screenTapPoint) && !backButton.isHidden {
            navigationController?.popViewController(animated: true)
            return
        }

        ...

        // If the back button is hidden and your hit test has no results... show the back button for a few seconds
        {
            let animationTime = 1.0
            let animationDelay = 3.0

            // Display back button for a few seconds
            UIView.animate(withDuration: animationTime, delay: 0, animations: {
                    self.backButton.alpha = 1.0
            }, completion:{ (finished: Bool) in
                self.backButton.isHidden = false
            })

            // Fade back out
            UIView.animate(withDuration: animationTime, delay: animationDelay, options: UIViewAnimationOptions.allowUserInteraction, animations: {
                self.backButton.alpha = 0
            }, completion: { (finished: Bool) in
                self.backButton.isHidden = true
            })
        }
     }
                </code></pre>

                <h3>Option 2: UINavigationController</h3>
                <p>If your ARSCNView is the child of a UINavigationController, you can hide the bar and use
                    UINavigationController's built-in "edge-pan to go back" gesture.</p>
                <p>In your <code>viewDidLoad()</code> method, set the <code>interactivePopGestureRecognizer</code>
                    Delegate to your ARViewController. This lets your ARSCNView pass edge-pad gestures to the view's
                    NavigationController.</p>

                <pre><code>
override func viewDidLoad() {
    ...
  // Required for "swipe right to go back" gesture with a hidden navigation bar
    navigationController?.interactivePopGestureRecognizer?.delegate = self
    ...
}
        </code></pre>

            </section>

        </div>
    </div>
    <div id="side">
        <!-- Sidebar -->
        <div class="inner">

            <!-- Menu -->
            <nav id="menu">
                <header class="major">
                    <h2>Menu</h2>
                </header>
                <ul>
                    <li><a href="../../index.html">Home</a></li>
                    <li><a href="../../arkit-samples.html">Sample Applications</a></li>
                </ul>
                <br/>
                <section>
                    <header class="major">
                        <h2 style="margin-bottom: 10px;">Tutorials</h2>
                    </header>
                    <nav>
                        <ul>
                            <li><a href="../arkit-hello-world/tutorial.html" target="_blank">Hello World</a></li>
                            <li><a href="../models-and-physics/tutorial.html" target="_blank">SceneKit Models and
                                Physics</a></li>
                        </ul>
                    </nav>
                </section>
                <br/>
                <section>
                    <header class="major">
                        <h2 style="margin-bottom: 10px;">Semester Project</h2>
                    </header>
                    <nav>
                        <ul>
                            <li><a href="/literature-review-site/tutorials/documentation/documentation.html">Documentation</a>
                            </li>
                        </ul>
                    </nav>
                </section>
            </nav>


            <!-- Footer -->
            <footer id="footer">
                <p class="copyright">&copy; Patrick Gatewood. All rights reserved. Design: <a
                        href="https://html5up.net">HTML5
                    UP</a>.</p>
            </footer>

        </div>
    </div>
</div>


<!-- Scripts -->
<script src="assets/js/jquery.min.js"></script>
<script src="assets/js/skel.min.js"></script>
<script src="assets/js/util.js"></script>
<!--[if lte IE 8]>
<script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
<script src="assets/js/main.js"></script>

<script src="assets/js/main.js"></script>

</body>
</html>